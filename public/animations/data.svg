import { useEffect, useRef, useState } from 'react';
import { useTheme } from 'next-themes';

// --- NEW CONCEPT: Data represented as particles or segments of a stream ---
interface DataParticle {
  id: number; // Unique ID
  x: number;
  y: number;
  vx: number; // Velocity x
  vy: number; // Velocity y
  // --- NEW: Properties for curved paths ---
  controlPoint1X?: number;
  controlPoint1Y?: number;
  controlPoint2X?: number;
  controlPoint2Y?: number;
  targetX: number;
  targetY: number;
  // --- Properties for appearance ---
  baseColor: string; // e.g., FHIR color
  targetColor: string; // e.g., JSONL color
  currentColor: string; // Current color during transition
  opacity: number;
  size: number;
  // --- State properties ---
  progress: number; // 0 = start, 1 = end of its path segment
  transformProgress: number; // 0 = FHIR, 1 = JSONL (used for color/form transition)
  state: 'entering' | 'processing' | 'exiting' | 'fadingOut';
  // --- Potential: Add properties for trails or specific particle shapes ---
  trail: { x: number; y: number }[]; // For drawing trails
}

// --- NEW CONCEPT: Central Transformative Area ---
interface TransformCore {
  x: number;
  y: number;
  radius: number; // Instead of width/height
  intensity: number; // Controls glow, swirl speed, etc. based on particles inside
  // --- Maybe internal patterns ---
  swirlAngle: number;
}

export function DataPreparationAnimation() {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const { theme } = useTheme();
  const isDark = theme === 'dark';

  // --- Remove stage definitions if using integrated text labels ---
  // const stages = [ ... ];

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext('2d'); // { alpha: true } is default and usually fine
    if (!ctx) return;

    let animationFrameId: number;
    // --- NEW: Use an array of particles instead of cards ---
    let particles: DataParticle[] = [];
    let nextParticleId = 0;
    let transformCore: TransformCore;

    let lastTimestamp = 0;
    const SPAWN_INTERVAL = 50; // ms - Spawn more frequently for streams
    let lastSpawnTime = 0;

    // --- NEW: Define colors more abstractly ---
    const fhirColor = isDark ? 'rgba(0, 240, 255, 0.8)' : 'rgba(0, 180, 190, 0.8)'; // Teal/Cyan
    const jsonlColor = isDark ? 'rgba(255, 180, 80, 0.8)' : 'rgba(255, 140, 50, 0.8)'; // Orange/Gold
    const coreColor = isDark ? 'rgba(200, 220, 255, 0.1)' : 'rgba(50, 80, 120, 0.1)'; // Subtle core background
    const coreGlow = isDark ? 'rgba(150, 200, 255, 0.5)' : 'rgba(80, 120, 180, 0.5)';

    const handleResize = () => {
      // ... (DPR scaling remains the same) ...
      const dpr = window.devicePixelRatio || 1;
      const clientWidth = canvas.clientWidth;
      const clientHeight = canvas.clientHeight;
      canvas.width = clientWidth * dpr;
      canvas.height = clientHeight * dpr;
      ctx.resetTransform();
      ctx.scale(dpr, dpr);

      // --- NEW: Define the Transform Core ---
      transformCore = {
        x: clientWidth / 2,
        y: clientHeight / 2, // Center it more vertically
        radius: Math.min(clientWidth, clientHeight) * 0.15, // Radius based on canvas size
        intensity: 0,
        swirlAngle: 0,
      };

      // --- Consider clearing or adjusting particles on resize ---
      particles = [];
    };

    handleResize();
    window.addEventListener('resize', handleResize);

    /**
     * Spawns a new particle for a data stream.
     */
    const spawnParticle = () => {
      const clientHeight = canvas.clientHeight;
      const startY = transformCore.y + (Math.random() - 0.5) * transformCore.radius * 1.5;
      const endY = transformCore.y + (Math.random() - 0.5) * transformCore.radius * 1.5;
      const clientWidth = canvas.clientWidth;

      // --- Define control points for a Bezier curve ---
      // Simple example: control points influence the curve towards/away from center line
      const cp1x = clientWidth * 0.2 + Math.random() * clientWidth * 0.1;
      const cp1y = startY + (transformCore.y - startY) * 0.3 + (Math.random() - 0.5) * 50;
      const cp2x = clientWidth * 0.8 - Math.random() * clientWidth * 0.1;
      const cp2y = transformCore.y + (endY - transformCore.y) * 0.7 + (Math.random() - 0.5) * 50;


      particles.push({
        id: nextParticleId++,
        x: -10, // Start off-screen left
        y: startY,
        vx: 0, // Velocity might be calculated based on curve progression
        vy: 0,
        controlPoint1X: cp1x,
        controlPoint1Y: cp1y,
        controlPoint2X: cp2x,
        controlPoint2Y: cp2y,
        targetX: clientWidth + 10, // End off-screen right
        targetY: endY,
        baseColor: fhirColor,
        targetColor: jsonlColor,
        currentColor: fhirColor,
        opacity: 0, // Start invisible, fade in
        size: Math.random() * 2 + 1, // Vary particle size
        progress: 0,
        transformProgress: 0,
        state: 'entering',
        trail: [],
      });
    };

    /**
     * Draw the sophisticated background.
     */
    const drawBackground = () => {
        const clientWidth = canvas.clientWidth;
        const clientHeight = canvas.clientHeight;
        ctx.fillStyle = isDark ? '#0a0a1a' : '#f4f8ff'; // Dark blue-black or very light blue/grey
        ctx.fillRect(0, 0, clientWidth, clientHeight);

        // --- NEW: Add subtle effects ---
        // Example: Very faint, large, slow-moving radial gradients for nebula effect
        // Or draw a subtle grid with slight perspective or warp near the center
        // Keep it minimal so it doesn't distract from the data flow.
        // This part requires more creative coding (e.g., using noise functions, multiple gradients).
    };

    /**
     * Draw the Transform Core.
     */
    const drawTransformCore = () => {
        const { x, y, radius, intensity } = transformCore;

        // --- NEW: Draw an abstract core ---
        ctx.save();
        // Outer glow - intensity affects blur radius
        ctx.shadowColor = coreGlow;
        ctx.shadowBlur = 10 + intensity * 20;

        // Base circle (subtle)
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fillStyle = coreColor;
        ctx.fill();

        // Internal dynamic elements (example: rotating/pulsing lines or inner circles)
        // Intensity could affect rotation speed, line thickness, or pulse frequency
        transformCore.swirlAngle += 0.005 * (1 + intensity); // Spin faster when active
        const numLines = 5;
        for (let i = 0; i < numLines; i++) {
            ctx.beginPath();
            const angle = transformCore.swirlAngle + (i * Math.PI * 2) / numLines;
            const startRadius = radius * 0.2;
            const endRadius = radius * (0.6 + Math.sin(performance.now() * 0.001 + i) * 0.1); // Pulsing size
            ctx.moveTo(x + Math.cos(angle) * startRadius, y + Math.sin(angle) * startRadius);
            ctx.lineTo(x + Math.cos(angle) * endRadius, y + Math.sin(angle) * endRadius);
            ctx.strokeStyle = `rgba(180, 210, 255, ${0.1 + intensity * 0.3})`; // Faint lines, brighter when active
            ctx.lineWidth = 1 + intensity;
            ctx.stroke();
        }

        ctx.restore();

        // --- NEW: Integrated Text Labels (Example) ---
        const labelFont = '14px "Inter", system-ui, sans-serif'; // Use a clean font
        const labelColor = isDark ? 'rgba(255, 255, 255, 0.6)' : 'rgba(0, 0, 0, 0.6)';
        ctx.font = labelFont;
        ctx.fillStyle = labelColor;
        ctx.textAlign = 'center';
        // Position labels appropriately relative to the flow
        ctx.fillText('FHIR Input', transformCore.x - transformCore.radius * 2.5, transformCore.y + transformCore.radius * 1.5);
        ctx.fillText('Transformation', transformCore.x, transformCore.y + transformCore.radius * 1.5);
        ctx.fillText('JSONL Output', transformCore.x + transformCore.radius * 2.5, transformCore.y + transformCore.radius * 1.5);

    };

    /**
     * Draw an individual particle.
     */
    const drawParticle = (p: DataParticle) => {
      ctx.save();
      ctx.globalAlpha = p.opacity;
      ctx.fillStyle = p.currentColor;

      // --- NEW: Draw particle (e.g., simple circle) ---
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fill();

      // --- Optional: Draw trail ---
      // ctx.strokeStyle = p.currentColor; // Maybe slightly fainter
      // ctx.lineWidth = p.size * 0.5;
      // ctx.beginPath();
      // ctx.moveTo(p.x, p.y);
      // for (let i = p.trail.length - 1; i >= 0; i--) {
      //     ctx.lineTo(p.trail[i].x, p.trail[i].y);
      // }
      // ctx.stroke();

      ctx.restore();
    };


    /**
     * Updates particle positions, colors, states.
     * @param dt - time in seconds since last frame
     */
    const updateParticles = (dt: number) => {
        let particlesInCore = 0;

        particles.forEach(p => {
            // --- NEW: Update progress along the path ---
            // This determines movement speed. Use easing functions for smoothness.
            const speed = 0.1; // Adjust as needed
            p.progress += speed * dt;
            p.progress = Math.min(p.progress, 1); // Cap at 1

            // --- NEW: Calculate position based on Bezier curve ---
            // Basic Bezier formula: B(t) = (1-t)^3 P0 + 3(1-t)^2 t P1 + 3(1-t) t^2 P2 + t^3 P3
            // Where P0 is start (-10, startY), P3 is end (clientWidth+10, endY), P1/P2 are control points
            // Need a function getBezierXY(t, startX, startY, cp1x, cp1y, cp2x, cp2y, endX, endY)
            // For simplicity, let's approximate with linear motion towards center, then linear away for now.
            // A proper Bezier or Catmull-Rom implementation would be smoother.

            // --- Simplified movement & state logic for example ---
            const distToCore = Math.sqrt(Math.pow(p.x - transformCore.x, 2) + Math.pow(p.y - transformCore.y, 2));
            const coreEntryRadius = transformCore.radius * 1.1; // Where transformation starts
            const coreExitRadius = transformCore.radius * 0.9;  // Where transformation ideally ends

            // Fade in
            if (p.opacity < 1 && p.state !== 'fadingOut') {
                p.opacity += 1.5 * dt; // Faster fade in
                p.opacity = Math.min(p.opacity, 1);
            }

            // Determine state and transformation
            if (p.state === 'entering' && distToCore < coreEntryRadius) {
                 p.state = 'processing';
            } else if (p.state === 'processing' && distToCore > coreEntryRadius * 1.2) { // Moved past the core
                 p.state = 'exiting';
                 p.transformProgress = 1; // Ensure it's fully transformed if it exits core zone
            }

            // Update transformation progress while 'processing'
            if (p.state === 'processing') {
                particlesInCore++;
                // Progress based on how far *through* the core it is (approximate)
                // Or simply progress over time while inside
                p.transformProgress += 1.0 * dt; // Speed of color change
                p.transformProgress = Math.min(p.transformProgress, 1);
            }

             // --- NEW: Interpolate color ---
             // Need a color interpolation function (e.g., lerp between RGB values)
             // p.currentColor = lerpColor(p.baseColor, p.targetColor, p.transformProgress);
             // Simple placeholder:
             if (p.transformProgress > 0.5) p.currentColor = p.targetColor; else p.currentColor = p.baseColor;


            // --- NEW: Move particle (using calculated velocity or curve progression) ---
            // Example: Simple constant velocity towards/away from core
            const angleToCore = Math.atan2(transformCore.y - p.y, transformCore.x - p.x);
            let currentSpeed = 80; // pixels per second
            if(p.state === 'processing') currentSpeed = 40; // Slower in core
            if(p.state === 'exiting') currentSpeed = 80;

            // Adjust velocity based on state (crude example)
            if(p.state === 'entering' || p.state === 'processing') {
                p.vx = Math.cos(angleToCore) * currentSpeed;
                p.vy = Math.sin(angleToCore) * currentSpeed;
            } else { // exiting - move roughly towards exit point
                const angleToExit = Math.atan2(p.targetY - p.y, p.targetX - p.x);
                p.vx = Math.cos(angleToExit) * currentSpeed;
                p.vy = Math.sin(angleToExit) * currentSpeed;
            }

            p.x += p.vx * dt;
            p.y += p.vy * dt;


            // --- Update Trail (simple) ---
            // p.trail.push({ x: p.x, y: p.y });
            // if (p.trail.length > 10) p.trail.shift(); // Keep trail length limited

            // Check for exit / fade out
            if (p.x > canvas.clientWidth + 10 && p.state !== 'fadingOut') {
                p.state = 'fadingOut';
            }
            if (p.state === 'fadingOut') {
                p.opacity -= 1.5 * dt;
            }
        });

        // Filter out fully faded particles
        particles = particles.filter(p => p.opacity > 0);

        // Update core intensity based on particles inside
        transformCore.intensity = Math.min(particlesInCore / 10, 1); // Example scaling
    };


    /**
     * Main animation loop.
     */
    const draw = (timestamp: number) => {
        if (!lastTimestamp) lastTimestamp = timestamp;
        const dt = (timestamp - lastTimestamp) / 1000;
        lastTimestamp = timestamp;

        const clientWidth = canvas.clientWidth;
        const clientHeight = canvas.clientHeight;
        ctx.clearRect(0, 0, clientWidth, clientHeight);

        drawBackground();

        if (timestamp - lastSpawnTime > SPAWN_INTERVAL) {
            // Limit max particles for performance if needed
            if(particles.length < 300) {
                 spawnParticle();
                 lastSpawnTime = timestamp;
            }
        }

        // Draw core FIRST (so particles flow over/through it)
        drawTransformCore();

        updateParticles(dt);
        // Draw particles SECOND
        // --- Use blending for glow effects ---
        ctx.globalCompositeOperation = 'lighter'; // Additive blending for glows
        particles.forEach(drawParticle);
        ctx.globalCompositeOperation = 'source-over'; // Reset to default


        animationFrameId = requestAnimationFrame(draw);
    };

    // --- Remove roundRect if not drawing cards ---
    // function roundRect(...) { ... }

    requestAnimationFrame(draw);

    return () => {
      window.removeEventListener('resize', handleResize);
      cancelAnimationFrame(animationFrameId);
    };
  }, [isDark]); // Keep dependency on isDark for colors

  return (
    <canvas
      ref={canvasRef}
      className="w-full h-[400px] rounded-lg" // Maybe increase height for more visual space
      // Remove inline background style if canvas draws its own opaque background
    />
  );
}